{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OmniNode: Autonomous Infrastructure Agents","text":"<p>Elevator Pitch: A hierarchical, multi-agent simulation where specialized Large Language Models (LLMs) collaborate via the Model Context Protocol (MCP) to monitor, optimize, and safely control critical physical infrastructure (like power grids, robotics, or satellite networks) autonomously.</p> <p>This project demonstrates how multiple specialized LLM agents can collaborate to manage critical infrastructure autonomously while ensuring operational safety.</p>"},{"location":"#key-scenarios","title":"\ud83d\udd25 Key Scenarios","text":"<p>The OmniNode architecture supports multiple interconnected domains: - \u26a1 Power Grid: Autonomous load balancing and fault protection (IEC 60255 compliant). - \ud83e\udd16 Robotics: Fleet coordination and path planning. - \ud83d\udef0\ufe0f Satellite: Constellation health monitoring.</p>"},{"location":"#safety-constitutional-ai","title":"\ud83d\udee1\ufe0f Safety &amp; Constitutional AI","text":"<p>Unlike standard agents, OmniNode implements a Guardian layer. Before any physical command (like opening a circuit breaker or adjusting thrusters) is sent to hardware, it is validated against a strict safety constitution to prevent hallucinated destruction. This ensures deterministic hardware safety even when using probabilistic LLM reasoning.</p>"},{"location":"#system-architecture","title":"\ud83c\udfd7 System Architecture","text":"<p>The system operates across three distinct layers, integrated seamlessly via MCP:</p> <pre><code>graph TD\n    Strategic[\"STRATEGIC LAYER&lt;br/&gt;'The Big Brain' (System-wide Agent)&lt;br/&gt;Resolves cross-zone issues, handles natural language UX\"]\n\n    ZoneC[\"COORDINATION LAYER&lt;br/&gt;Zone PLCs (Substation Agents)&lt;br/&gt;Deterministic IEC 60255 protection logic and local optimization\"]\n\n    Physical[\"PHYSICAL LAYER&lt;br/&gt;Digital Twin (Pandapower)&lt;br/&gt;Sensor servers (Voltage, Current, Frequency)&lt;br/&gt;Actuator servers (Circuit Breakers, Generators)\"]\n\n    Strategic &lt;--&gt;|MCP Protocol JSON-RPC| ZoneC\n    ZoneC &lt;--&gt;|MCP Protocol JSON-RPC| Physical</code></pre>"},{"location":"#the-component-roster","title":"The Component Roster","text":"<p>The system runs the following roster of interconnected servers and agents: - 1\u00d7 Strategic Agent: A master LLM (e.g., <code>llama3.1</code>) that reasons over the entire grid state, processes human commands, and acts as the ultimate decider for high-risk operations. - 3\u00d7 Zone Coordinators (PLCs): Deterministic, rule-based agents assigned to geographic zones (Buses 0\u20139, 10\u201319, 20\u201329). They handle local load balancing and voltage regulation autonomously using hard-coded safety rules (IEC 60255). - 11\u00d7 Sensor MCP Servers: Continuous readers for Voltage, Current, Transformer Temperature, Power Quality (THD), and System Frequency. - 5\u00d7 Actuator MCP Servers: Interfaces for Circuit Breakers, Generators, Load Controllers, Voltage Regulators (shunt capacitors), and Energy Storage. - 1\u00d7 Safety Guardian Agent: (Optional config) Validates actuator commands before execution. - 1\u00d7 MCP Registry: A lightweight discovery service (<code>FastAPI</code>) where all sensor, actuator, and coordinator tools are registered for discovery by the Strategic Agent.</p>"},{"location":"#project-structure","title":"\ud83d\udee0 Project Structure","text":"<pre><code>mcp-multi-agent/\n\u251c\u2500\u2500 pyproject.toml             # Python dependencies (uv)\n\u251c\u2500\u2500 .env                       # Environment configuration (LLMs, API keys)\n\u251c\u2500\u2500 scripts/\n\u2502   \u2514\u2500\u2500 start_all.py           # Main orchestrator script to launch all servers\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 common/                # Shared settings, LLM client wrapper, data models\n\u2502   \u251c\u2500\u2500 registry/              # FastAPI MCP registry server (`mcp-registry`)\n\u2502   \u251c\u2500\u2500 simulation/            # IEEE 30-bus Pandapower digital twin &amp; data generation\n\u2502   \u251c\u2500\u2500 physical/              # Physical Layer MCP Servers\n\u2502   \u2502   \u251c\u2500\u2500 sensors/           # Voltage, current, temperature, frequency MCP servers\n\u2502   \u2502   \u2514\u2500\u2500 actuators/         # Breaker, generator, capacitor MCP servers\n\u2502   \u251c\u2500\u2500 coordination/          # Zone Coordinator MCP servers &amp; optimization heuristics\n\u2502   \u251c\u2500\u2500 strategic/             # Strategic Agent, CLI, Memory, and Monitoring Loop\n\u2502   \u251c\u2500\u2500 dashboard/             # Plotly Dash real-time monitoring UI\n\u2502   \u2514\u2500\u2500 domains/               # Domain adapters wrapping the simulation for MCP\n\u2514\u2500\u2500 tests/                     # Unit and integration tests\n</code></pre>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Launch the entire ecosystem with a one-liner: <pre><code>git clone https://github.com/charansoma3001/OmniNode &amp;&amp; cd OmniNode &amp;&amp; uv sync &amp;&amp; docker-compose up -d\n</code></pre></p>"},{"location":"#installation-details","title":"Installation Details","text":"<ol> <li> <p>Clone and Install Dependencies: <pre><code>uv sync --all-extras\n</code></pre></p> </li> <li> <p>Start Infrastructure Services:    Spin up the required MQTT broker and InfluxDB instances:    <pre><code>docker-compose up -d\n</code></pre></p> </li> <li> <p>Configure Environment:    Copy the <code>.env</code> template or create a new <code>.env</code> file in the root directory:    <pre><code># /mcp-multi-agent/.env\n\n# Strategic agent: cross-zone reasoning\nSTRATEGIC_MODEL=llama3.1:latest\n\n# LLM Connection\nLLM_API_KEY=ollama\nLLM_BASE_URL=http://localhost:11434\nLLM_CONTEXT_WINDOW=8192  # Increased for complex grid state reasoning\n</code></pre> Note: Ensure the specified Ollama models are pulled (<code>ollama pull &lt;model_name&gt;</code>) before starting.</p> </li> </ol>"},{"location":"#running-the-system","title":"\u25b6\ufe0f Running the System","text":"<p>To run the full suite, you need to open multiple terminal instances. The project leverages <code>uv run</code> to ensure scripts execute within the correct virtual environment path.</p> <p>Terminal 1: Start the MCP Service Registry The registry acts as the phonebook for all tools. <pre><code>uv run mcp-registry\n</code></pre></p> <p>Terminal 2: Launch the Digital Twin &amp; Agents This script initializes the IEEE 30-bus simulation, generates MCP server wrappers for all components, registers them, and starts the asynchronous monitoring loop. <pre><code>uv run python scripts/start_all.py\n</code></pre></p> <p>Terminal 3: Launch the Real-Time Dashboard View the grid state visually (Voltage bars, line loading, zone health). <pre><code>uv run mcp-dashboard\n# Access at http://localhost:8050\n</code></pre></p> <p>Terminal 4: Launch the Natural Language Interactive CLI The primary interface to chat with the Strategic Agent and issue commands. <pre><code>uv run mcp-cli\n</code></pre></p>"},{"location":"#interacting-with-the-system","title":"\ud83d\udcbb Interacting with the System","text":"<p>Once the <code>mcp-cli</code> is running, you can issue both internal commands and natural language prompts:</p>"},{"location":"#built-in-cli-commands","title":"Built-in CLI Commands","text":"<ul> <li><code>status</code>: Prints a system-wide overview (Generation, Load, Losses, Frequency, Max Voltage/Loading).</li> <li><code>zones</code>: Displays instantaneous health summaries for Zone 1, Zone 2, and Zone 3.</li> <li><code>history</code>: Shows the last 5 decisions made by the Strategic Agent.</li> <li><code>monitor start / stop</code>: Toggles the background monitoring loop.</li> <li><code>rollback</code>: Reverts the grid state to the original baseline snapshot.</li> <li><code>scenario &lt;name&gt;</code>: Injects a pre-defined fault or demand spike (e.g., <code>scenario peak_load</code>).</li> <li><code>exit</code> or <code>quit</code>: Shut down the CLI.</li> </ul>"},{"location":"#natural-language-control","title":"Natural Language Control","text":"<p>You can type instructions natively. The Strategic Agent translates these into MCP tool executions.</p> <p>Examples: - \"Why is Zone 3 showing a critical warning, and can you fix it?\" - \"Open the circuit breaker on line 5 to simulate a fault and tell me what happens to the voltages.\" - \"Increase generation at bus 1 to 45 MW to handle the load.\" - \"Run a complete diagnostic of the system and resolve any existing voltage violations using the zone coordinators.\"</p>"},{"location":"#how-the-ai-monitoring-loop-works","title":"\ud83e\udde0 How the AI Monitoring Loop Works","text":"<p>When you run <code>start_all.py</code>, an asynchronous <code>MonitoringLoop</code> begins. Here is what happens every interval (e.g., 30 seconds):</p> <ol> <li>Simulation Tick: Loads fluctuate slightly via the <code>DataGenerator</code>, and <code>pandapower</code> runs a power flow analysis.</li> <li>Violation Detection: The system checks voltages (0.95\u20131.05 p.u.), line loadings (&lt; 100%), and frequency.</li> <li>Zone-First Delegation: If violations exist, they are grouped by zone and dispatched to the respective Zone Coordinator PLCs in parallel.</li> <li>Autonomous Correction: Zone PLCs evaluate their domains against deterministic safety rules (e.g., IEC 60255) and execute local tools (e.g., switching shunt capacitors or shifting load) to fix the grid.</li> <li>Strategic Escalation: If multiple zones are failing, or a zone specifically requests help (\"Escalate to strategic agent\"), the violations are aggregated and fed into the Strategic Agent.</li> <li>Master Execution: The Strategic Agent reads the context and executes cross-zone or high-risk tools to stabilize the grid.</li> </ol>"},{"location":"#extensibility","title":"\ud83d\udd27 Extensibility","text":"<p>Because the system is built strictly using the Model Context Protocol, adding new capabilities is incredibly straightforward:</p> <ol> <li>New Sensors/Actuators: Create a new class extending <code>mcp.server.Server</code>. Add <code>@self.mcp.list_tools()</code> and <code>@self.mcp.call_tool()</code> decorators. Register it in the <code>PowerGridAdapter</code>.</li> <li>New Domains: You can replace <code>src/simulation/power_grid.py</code> with an adapter for a robotics system or a satellite network. As long as they expose MCP servers, the Strategic Agent LLM can discover and operate them.</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>This section contains automatically generated API documentation from the Python source code, utilizing <code>mkdocstrings</code>.</p>"},{"location":"api/#coordination-layer","title":"Coordination Layer","text":""},{"location":"api/#zone-coordinator","title":"Zone Coordinator","text":""},{"location":"api/#src.coordination.zone_coordinator","title":"<code>src.coordination.zone_coordinator</code>","text":"<p>Zone/Substation Coordinator MCP Server.</p> <p>Each zone coordinator manages a subset of buses/lines and provides: - Local optimization with its own LLM brain - Autonomous violation handling - Inter-zone coordination</p>"},{"location":"api/#src.coordination.zone_coordinator.ZoneCoordinator","title":"<code>ZoneCoordinator</code>","text":"<p>MCP server for a geographic zone of the power grid.</p> <p>Aggregates sensor data, runs local optimization, handles violations, and coordinates with peer zones.</p> Source code in <code>src/coordination/zone_coordinator.py</code> <pre><code>class ZoneCoordinator:\n    \"\"\"MCP server for a geographic zone of the power grid.\n\n    Aggregates sensor data, runs local optimization, handles violations,\n    and coordinates with peer zones.\n    \"\"\"\n\n    def __init__(\n        self,\n        zone_id: str,\n        grid: PowerGridSimulation,\n        buses: list[int],\n        lines: list[int]\n    ):\n        self.zone_id = zone_id\n        self.grid = grid\n        self.buses = buses\n        self.lines = lines\n        self.server_id = f\"coordinator_{zone_id}_{uuid.uuid4().hex[:8]}\"\n        self.name = f\"Zone Coordinator PLC ({zone_id})\"\n        self.optimizer = ZoneOptimizer(grid, zone_id, buses, lines)\n        self.audit_log = ZoneAuditLogger()\n        self.mqtt: MQTTClient | None = None\n\n        # Deterministic Protection Thresholds (adjustable via MCP)\n        self.protection_settings = {\n            \"under_voltage_pu\": 0.95,\n            \"over_voltage_pu\": 1.05,\n            \"max_line_loading_pct\": 100.0,\n        }\n\n        # State tracking for deadband/escalation\n        self._consecutive_violations = 0\n\n        self.mcp = Server(self.name)\n        self._register_tools()\n\n    def _register_tools(self) -&gt; None:\n        @self.mcp.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            return [\n                Tool(\n                    name=\"get_zone_status\",\n                    description=f\"Get comprehensive status of {self.zone_id}\",\n                    inputSchema={\"type\": \"object\", \"properties\": {}},\n                ),\n                Tool(\n                    name=\"optimize_zone_topology\",\n                    description=f\"Optimize {self.zone_id} for a given objective\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"objective\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"min_losses\", \"min_voltage_deviation\", \"balance_loading\"],\n                                \"description\": \"Optimization objective\",\n                            }\n                        },\n                        \"required\": [\"objective\"],\n                    },\n                ),\n                Tool(\n                    name=\"handle_violation\",\n                    description=f\"Handle a constraint violation in {self.zone_id}\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"violation_type\": {\"type\": \"string\", \"enum\": [\"voltage\", \"thermal\", \"frequency\"]},\n                            \"affected_components\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n                        },\n                        \"required\": [\"violation_type\"],\n                    },\n                ),\n                Tool(\n                    name=\"load_balancing\",\n                    description=f\"Redistribute load within {self.zone_id}\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"target_balance\": {\"type\": \"number\", \"description\": \"Target loading % per line (0-100)\"}\n                        },\n                    },\n                ),\n                Tool(\n                    name=\"voltage_regulation\",\n                    description=f\"Adjust voltage profile in {self.zone_id}\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"target_pu\": {\"type\": \"number\", \"description\": \"Target voltage in p.u.\", \"default\": 1.0}\n                        },\n                    },\n                ),\n                Tool(\n                    name=\"emergency_islanding\",\n                    description=f\"Isolate {self.zone_id} from the rest of the grid\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"reason\": {\"type\": \"string\"}\n                        },\n                        \"required\": [\"reason\"],\n                    },\n                ),\n                Tool(\n                    name=\"detect_violations\",\n                    description=f\"Scan {self.zone_id} for constraint violations\",\n                    inputSchema={\"type\": \"object\", \"properties\": {}},\n                ),\n                Tool(\n                    name=\"execute_safety_rules\",\n                    description=f\"Evaluate deterministic IEC 60255 protection rules for {self.zone_id} and execute hardware actions\",\n                    inputSchema={\"type\": \"object\", \"properties\": {}},\n                ),\n                Tool(\n                    name=\"update_protection_settings\",\n                    description=f\"Update protection relay trip thresholds for {self.zone_id}\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"under_voltage_pu\": {\"type\": \"number\", \"description\": \"Trip threshold for under-voltage\"},\n                            \"over_voltage_pu\": {\"type\": \"number\", \"description\": \"Trip threshold for over-voltage\"},\n                            \"max_line_loading_pct\": {\"type\": \"number\", \"description\": \"Trip threshold for thermal overload\"},\n                        },\n                    },\n                ),\n            ]\n\n        @self.mcp.call_tool()\n        async def call_tool(name: str, arguments: dict) -&gt; list[TextContent]:\n            try:\n                if name == \"get_zone_status\":\n                    result = self._get_zone_status()\n                elif name == \"optimize_zone_topology\":\n                    result = self.optimizer.optimize(arguments[\"objective\"])\n                elif name == \"handle_violation\":\n                    result = self._handle_violation(arguments)\n                elif name == \"load_balancing\":\n                    result = self.optimizer.balance_loading(arguments.get(\"target_balance\", 80))\n                elif name == \"voltage_regulation\":\n                    result = self.optimizer.regulate_voltage(arguments.get(\"target_pu\", 1.0))\n                elif name == \"emergency_islanding\":\n                    result = self._emergency_island(arguments.get(\"reason\", \"\"))\n                elif name == \"detect_violations\":\n                    result = self._detect_violations()\n                elif name == \"execute_safety_rules\":\n                    result = self._evaluate_safety_rules()\n                elif name == \"update_protection_settings\":\n                    self.protection_settings.update({k: v for k, v in arguments.items() if v is not None})\n                    self.audit_log.log_event(self.zone_id, \"SETTINGS_UPDATED\", \"Protection thresholds revised\", details=self.protection_settings)\n                    self._broadcast_state(\"settings_updated\", self.protection_settings)\n                    result = {\"status\": \"success\", \"settings\": self.protection_settings}\n                else:\n                    result = {\"error\": f\"Unknown tool: {name}\"}\n                return [TextContent(type=\"text\", text=json.dumps(result, default=str))]\n            except Exception as e:\n                logger.error(\"Error in coordinator %s.%s: %s\", self.zone_id, name, e)\n                return [TextContent(type=\"text\", text=json.dumps({\"error\": str(e)}))]\n\n    # ------------------------------------------------------------------\n    # Status\n    # ------------------------------------------------------------------\n\n    def _get_zone_status(self) -&gt; dict:\n        voltages = {b: self.grid.get_bus_voltage(b) for b in self.buses}\n        loadings = {}\n        for lid in self.lines:\n            try:\n                loadings[lid] = float(self.grid.net.res_line.loading_percent.at[lid])\n            except (KeyError, IndexError):\n                pass\n\n        # Loads in zone\n        zone_loads = self.grid.net.load[self.grid.net.load.bus.isin(self.buses)]\n        total_load = float(zone_loads.p_mw.sum()) if len(zone_loads) &gt; 0 else 0\n\n        # Generators in zone\n        zone_gens = self.grid.net.gen[self.grid.net.gen.bus.isin(self.buses)]\n        total_gen = float(zone_gens.p_mw.sum()) if len(zone_gens) &gt; 0 else 0\n\n        violations = self._detect_violations()\n\n        return {\n            \"zone_id\": self.zone_id,\n            \"buses\": self.buses,\n            \"num_lines\": len(self.lines),\n            \"voltages\": {str(k): round(v, 4) for k, v in voltages.items()},\n            \"min_voltage\": round(min(voltages.values()), 4) if voltages else None,\n            \"max_voltage\": round(max(voltages.values()), 4) if voltages else None,\n            \"avg_line_loading\": round(sum(loadings.values()) / max(len(loadings), 1), 2),\n            \"max_line_loading\": round(max(loadings.values()), 2) if loadings else 0,\n            \"total_load_mw\": round(total_load, 2),\n            \"total_gen_mw\": round(total_gen, 2),\n            \"violations\": violations,\n            \"health\": \"critical\" if violations.get(\"count\", 0) &gt; 2 else \"warning\" if violations.get(\"count\", 0) &gt; 0 else \"normal\",\n        }\n\n    # ------------------------------------------------------------------\n    # Violation handling\n    # ------------------------------------------------------------------\n\n    def _detect_violations(self) -&gt; dict:\n        violations = []\n        for b in self.buses:\n            try:\n                vm = self.grid.get_bus_voltage(b)\n                if vm &lt; self.protection_settings[\"under_voltage_pu\"]:\n                    violations.append({\"type\": \"voltage_low\", \"bus\": b, \"value\": round(vm, 4), \"limit\": self.protection_settings[\"under_voltage_pu\"]})\n                elif vm &gt; self.protection_settings[\"over_voltage_pu\"]:\n                    violations.append({\"type\": \"voltage_high\", \"bus\": b, \"value\": round(vm, 4), \"limit\": self.protection_settings[\"over_voltage_pu\"]})\n            except (KeyError, IndexError):\n                pass\n\n        for lid in self.lines:\n            try:\n                loading = float(self.grid.net.res_line.loading_percent.at[lid])\n                if loading &gt; self.protection_settings[\"max_line_loading_pct\"]:\n                    violations.append({\"type\": \"thermal\", \"line\": lid, \"value\": round(loading, 2), \"limit\": self.protection_settings[\"max_line_loading_pct\"]})\n            except (KeyError, IndexError):\n                pass\n\n        return {\"violations\": violations, \"count\": len(violations), \"zone\": self.zone_id}\n\n    def _handle_violation(self, args: dict) -&gt; dict:\n        vtype = args[\"violation_type\"]\n        affected = args.get(\"affected_components\", [])\n\n        if vtype == \"voltage\":\n            return self.optimizer.regulate_voltage(1.0)\n        elif vtype == \"thermal\":\n            return self.optimizer.balance_loading(80)\n        elif vtype == \"frequency\":\n            return {\"action\": \"frequency_response\", \"message\": \"Frequency handled at system level\"}\n        else:\n            return {\"error\": f\"Unknown violation type: {vtype}\"}\n\n    def _emergency_island(self, reason: str) -&gt; dict:\n        \"\"\"Isolate the zone by opening all tie lines.\"\"\"\n        all_lines = list(self.grid.net.line.index)\n        tie_lines = []\n        for lid in all_lines:\n            fb = int(self.grid.net.line.from_bus.at[lid])\n            tb = int(self.grid.net.line.to_bus.at[lid])\n            in_zone = fb in self.buses or tb in self.buses\n            both_in = fb in self.buses and tb in self.buses\n            if in_zone and not both_in:\n                tie_lines.append(lid)\n\n        # Validate first\n        snapshot = self.grid.save_snapshot()\n        for lid in tie_lines:\n            self.grid.net.line.in_service.at[lid] = False\n\n        converged = self.grid.run_power_flow()\n        if not converged:\n            self.grid.restore_snapshot(snapshot)\n            return {\"islanded\": False, \"reason\": \"Power flow does not converge after islanding\", \"tie_lines\": tie_lines}\n\n        return {\n            \"islanded\": True,\n            \"reason\": reason,\n            \"tie_lines_opened\": tie_lines,\n            \"converged\": converged,\n        }\n\n    # ------------------------------------------------------------------\n    # Deterministic PLC Logic (IEC 60255 Emulation)\n    # ------------------------------------------------------------------\n\n    def _evaluate_safety_rules(self) -&gt; dict:\n        \"\"\"Deterministic rule engine executing hard-coded safety logic.\"\"\"\n        status = self._get_zone_status()\n        violations = self._detect_violations()\n        v_list = violations.get(\"violations\", [])\n\n        actions_taken = []\n        events_logged = []\n        escalate = False\n\n        if violations[\"count\"] &gt; 0:\n            self._consecutive_violations += 1\n        else:\n            self._consecutive_violations = 0\n\n        topics = []\n\n        # Rule 4: Strategic Escalation Deadband\n        if self._consecutive_violations &gt;= 3:\n            msg = f\"Escalating: Unable to resolve {violations['count']} violations after 3 cycles.\"\n            self.audit_log.log_event(self.zone_id, \"ESCALATION\", msg, details=violations)\n            self._broadcast_state(\"escalation\", {\"violations\": violations})\n            return {\n                \"zone\": self.zone_id,\n                \"status\": \"escalation_required\",\n                \"violations\": violations,\n                \"message\": msg\n            }\n\n        # Rule 1 &amp; Rule 2: Voltage Protection (ANSI 27 &amp; 59 / IEC 60255-127)\n        if any(v[\"type\"] in (\"voltage_low\", \"voltage_high\") for v in v_list):\n            msg = \"IEC 60255-127 Voltage Relay Triggered.\"\n            result = self.optimizer.regulate_voltage(1.0)\n            act = \"Capacitor banks switched to regulate voltage.\"\n            actions_taken.append({\"action\": \"voltage_regulation\", \"result\": result})\n            self.audit_log.log_event(self.zone_id, \"RELAY_TRIP\", msg, action_taken=act, details=result)\n            topics.append(\"relay_trip\")\n            events_logged.append(msg)\n\n        # Rule 3: Thermal Overload (ANSI 50/51 / IEC 60255-151)\n        if any(v[\"type\"] == \"thermal\" for v in v_list):\n            msg = \"IEC 60255-151 Overcurrent Relay Triggered.\"\n            # Shed load dynamically, aiming for 95% of limit to create buffer\n            target = self.protection_settings[\"max_line_loading_pct\"] * 0.95\n            result = self.optimizer.balance_loading(target)\n            act = f\"Local demand response triggered (Target: {target}%).\"\n            actions_taken.append({\"action\": \"thermal_protection\", \"result\": result})\n            self.audit_log.log_event(self.zone_id, \"RELAY_TRIP\", msg, action_taken=act, details=result)\n            topics.append(\"relay_trip\")\n            events_logged.append(msg)\n\n        post_violations = self._detect_violations()\n\n        result_payload = {\n            \"zone\": self.zone_id,\n            \"violations_before\": violations.get(\"count\", 0),\n            \"violations_after\": post_violations.get(\"count\", 0),\n            \"actions_taken\": actions_taken,\n            \"events\": events_logged,\n            \"mode\": \"deterministic_plc\",\n        }\n\n        # Broadcast status updates\n        self._broadcast_state(\"status\", self._get_zone_status())\n        for topic in topics:\n            self._broadcast_state(topic, result_payload)\n\n        return result_payload\n\n    # ------------------------------------------------------------------\n    # MQTT Communication\n    # ------------------------------------------------------------------\n\n    def _broadcast_state(self, topic_suffix: str, payload: dict) -&gt; None:\n        \"\"\"Broadcast an event or state over MQTT to all subscribers.\"\"\"\n        if not self.mqtt:\n            return\n\n        topic = f\"grid/{self.zone_id}/{topic_suffix}\"\n\n        # We fire and forget asynchronously in the background\n        import asyncio\n        asyncio.create_task(self._publish_async(topic, payload))\n\n    async def _publish_async(self, topic: str, payload: dict) -&gt; None:\n        try:\n            msg = json.dumps(payload, default=str)\n            await self.mqtt.publish(topic, msg)\n        except Exception as e:\n            logger.error(\"Failed to broadcast on %s: %s\", topic, e)\n\n    # ------------------------------------------------------------------\n    # Registry\n    # ------------------------------------------------------------------\n\n    def get_registration(self) -&gt; MCPServerRegistration:\n        tools = [\n            ToolDescriptor(name=\"get_zone_status\", description=\"Zone status overview\", safety_level=SafetyLevel.READ_ONLY),\n            ToolDescriptor(name=\"optimize_zone_topology\", description=\"Local optimization\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"handle_violation\", description=\"Violation response\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"load_balancing\", description=\"Load redistribution\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"voltage_regulation\", description=\"Voltage control\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"emergency_islanding\", description=\"Zone isolation\", safety_level=SafetyLevel.HIGH_RISK),\n            ToolDescriptor(name=\"detect_violations\", description=\"Violation scan\", safety_level=SafetyLevel.READ_ONLY),\n            ToolDescriptor(name=\"execute_safety_rules\", description=\"PLC Deterministic Rules Evaluation\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"update_protection_settings\", description=\"Revise safety thresholds\", safety_level=SafetyLevel.HIGH_RISK),\n        ]\n        return MCPServerRegistration(\n            server_id=self.server_id,\n            name=self.name,\n            layer=\"coordination\",\n            domain=\"power_grid\",\n            zone=self.zone_id,\n            transport=\"stdio\",\n            tools=tools,\n        )\n\n    async def register_with_registry(self) -&gt; None:\n        settings = get_settings()\n        reg = self.get_registration()\n        try:\n            async with httpx.AsyncClient() as client:\n                resp = await client.post(\n                    f\"{settings.registry_url}/register\",\n                    json=reg.model_dump(mode=\"json\"),\n                )\n                resp.raise_for_status()\n                logger.info(\"Registered %s with registry\", self.name)\n        except Exception as e:\n            logger.warning(\"Failed to register with registry: %s\", e)\n\n    async def run(self) -&gt; None:\n        settings = get_settings()\n        self.mqtt = MQTTClient(\n            settings.mqtt_broker,\n            settings.mqtt_port,\n            client_id=f\"zone_{self.zone_id}_{uuid.uuid4().hex[:4]}\"\n        )\n        await self.mqtt.connect()\n        self.audit_log.log_event(self.zone_id, \"SYSTEM_START\", \"Zone PLC Relay Initialized Offline\", details={\"buses\": self.buses})\n\n        await self.register_with_registry()\n\n        async with stdio_server() as (read, write):\n            await self.mcp.run(read, write, self.mcp.create_initialization_options())\n</code></pre>"},{"location":"api/#domain-adapters","title":"Domain Adapters","text":""},{"location":"api/#base-adapter","title":"Base Adapter","text":""},{"location":"api/#src.domains.base_adapter","title":"<code>src.domains.base_adapter</code>","text":"<p>Abstract base class for domain adapters.</p> <p>Each domain (power grid, robotics, satellite) extends this to provide domain-specific sensors, actuators, and coordinators.</p>"},{"location":"api/#src.domains.base_adapter.DomainAdapter","title":"<code>DomainAdapter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract domain adapter providing a uniform interface for multi-domain support.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>class DomainAdapter(ABC):\n    \"\"\"Abstract domain adapter providing a uniform interface for multi-domain support.\"\"\"\n\n    @property\n    @abstractmethod\n    def domain_name(self) -&gt; str:\n        \"\"\"Return the domain identifier (e.g., 'power_grid', 'robotics').\"\"\"\n        ...\n\n    @abstractmethod\n    def get_sensor_types(self) -&gt; list[dict]:\n        \"\"\"Return list of sensor type definitions for this domain.\"\"\"\n        ...\n\n    @abstractmethod\n    def get_actuator_types(self) -&gt; list[dict]:\n        \"\"\"Return list of actuator type definitions for this domain.\"\"\"\n        ...\n\n    @abstractmethod\n    def create_sensors(self, simulation: Any) -&gt; list[Any]:\n        \"\"\"Instantiate all sensor MCP servers for this domain.\"\"\"\n        ...\n\n    @abstractmethod\n    def create_actuators(self, simulation: Any) -&gt; list[Any]:\n        \"\"\"Instantiate all actuator MCP servers for this domain.\"\"\"\n        ...\n\n    @abstractmethod\n    def create_coordinators(self, simulation: Any) -&gt; list[Any]:\n        \"\"\"Instantiate zone/area coordinator MCP servers.\"\"\"\n        ...\n\n    def get_constraints(self) -&gt; dict:\n        \"\"\"Return domain-specific constraints and limits.\"\"\"\n        return {}\n\n    def get_safety_rules(self) -&gt; list[str]:\n        \"\"\"Return domain-specific safety rules.\"\"\"\n        return []\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.domain_name","title":"<code>domain_name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the domain identifier (e.g., 'power_grid', 'robotics').</p>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.create_actuators","title":"<code>create_actuators(simulation)</code>  <code>abstractmethod</code>","text":"<p>Instantiate all actuator MCP servers for this domain.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef create_actuators(self, simulation: Any) -&gt; list[Any]:\n    \"\"\"Instantiate all actuator MCP servers for this domain.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.create_coordinators","title":"<code>create_coordinators(simulation)</code>  <code>abstractmethod</code>","text":"<p>Instantiate zone/area coordinator MCP servers.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef create_coordinators(self, simulation: Any) -&gt; list[Any]:\n    \"\"\"Instantiate zone/area coordinator MCP servers.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.create_sensors","title":"<code>create_sensors(simulation)</code>  <code>abstractmethod</code>","text":"<p>Instantiate all sensor MCP servers for this domain.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef create_sensors(self, simulation: Any) -&gt; list[Any]:\n    \"\"\"Instantiate all sensor MCP servers for this domain.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.get_actuator_types","title":"<code>get_actuator_types()</code>  <code>abstractmethod</code>","text":"<p>Return list of actuator type definitions for this domain.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef get_actuator_types(self) -&gt; list[dict]:\n    \"\"\"Return list of actuator type definitions for this domain.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.get_constraints","title":"<code>get_constraints()</code>","text":"<p>Return domain-specific constraints and limits.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>def get_constraints(self) -&gt; dict:\n    \"\"\"Return domain-specific constraints and limits.\"\"\"\n    return {}\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.get_safety_rules","title":"<code>get_safety_rules()</code>","text":"<p>Return domain-specific safety rules.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>def get_safety_rules(self) -&gt; list[str]:\n    \"\"\"Return domain-specific safety rules.\"\"\"\n    return []\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.get_sensor_types","title":"<code>get_sensor_types()</code>  <code>abstractmethod</code>","text":"<p>Return list of sensor type definitions for this domain.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef get_sensor_types(self) -&gt; list[dict]:\n    \"\"\"Return list of sensor type definitions for this domain.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#power-grid-adapter","title":"Power Grid Adapter","text":""},{"location":"api/#src.domains.power_grid","title":"<code>src.domains.power_grid</code>","text":""},{"location":"configuration/","title":"Configuration Guide","text":"<p>The project leverages both environment variables and on-disk JSON data stores to share state seamlessly between the simulation, the MCP registry, and the various operational agents.</p>"},{"location":"configuration/#environment-variables-env","title":"Environment Variables (<code>.env</code>)","text":"<p>The system requires an environment file (<code>.env</code>) placed in the root directory. Copy the <code>.env.example</code> file to start.</p> Variable Description Default <code>STRATEGIC_MODEL</code> The LLM model name used for the top-level Strategic Agent. <code>llama3.1:latest</code> <p>| <code>LLM_API_KEY</code> | Key for authentication (can be anything if local). | <code>ollama</code> | | <code>LLM_BASE_URL</code> | Endpoint for the OpenAI-compatible completion API. | <code>http://localhost:11434</code> | | <code>LLM_CONTEXT_WINDOW</code> | Maximum tokens allowed for the context window. | <code>8192</code> |</p>"},{"location":"configuration/#state-management-files","title":"State Management Files","text":""},{"location":"configuration/#grid_statejson","title":"<code>grid_state.json</code>","text":"<p>This is the central \"digital twin\" storage file updated continuously by the <code>PowerGridAdapter</code>.  It holds the latest snapshot of the physical simulation.</p> <p>Structure: <pre><code>{\n  \"timestamp\": \"2023-10-24T12:00:00Z\",\n  \"buses\": [\n    {\n      \"id\": 0,\n      \"zone\": \"Zone 1\",\n      \"voltage_pu\": 1.02,\n      \"type\": \"slack\"\n    }\n  ],\n  \"lines\": [\n    {\n      \"id\": 0,\n      \"from_bus\": 0,\n      \"to_bus\": 1,\n      \"loading_percent\": 45.3,\n      \"status\": \"closed\"\n    }\n  ],\n  \"generators\": [...],\n  \"loads\": [...]\n}\n</code></pre></p>"},{"location":"configuration/#registry_storejson","title":"<code>registry_store.json</code>","text":"<p>This file is managed exclusively by the <code>mcp-registry</code> (FastAPI). It holds a list of all currently active MCP servers (sensors, actuators, coordinators).</p> <p>Structure: <pre><code>{\n  \"servers\": {\n    \"voltage_sensor_zone1\": {\n      \"type\": \"sensor\",\n      \"url\": \"http://localhost:8001/mcp\",\n      \"status\": \"online\",\n      \"last_heartbeat\": \"2023-10-24T12:00:05Z\"\n    },\n    ...\n  }\n}\n</code></pre> Agents query this file (via the registry API) to perform dynamic tool discovery.</p>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>The MCP Multi-Agent System is designed to seamlessly integrate Large Language Models (LLMs) with simulated physical systems. </p>"},{"location":"core-concepts/#the-domains","title":"The Domains","text":"<p>The architecture supports various physical domains by wrapping their simulation data into standard Model Context Protocol (MCP) servers.</p> <ul> <li>Power Grid (IEEE 30-bus): The primary simulation provided. It models the generation, transmission, and load aspects of an electrical grid using <code>pandapower</code>. It provides sensor data (voltage, current, frequency) and actuator controls (breakers, generators).</li> <li>Robotics (Future Extension): Control endpoints for individual servos, kinematics calculations, and LiDAR sensor simulation.</li> <li>Satellite (Future Extension): Orbital parameters, communication bandwidth, and power management simulations.</li> </ul>"},{"location":"core-concepts/#the-multi-agent-system","title":"The Multi-Agent System","text":"<p>The system operates across three tiers:</p>"},{"location":"core-concepts/#1-the-strategic-agent-system-wide","title":"1. The Strategic Agent (System-wide)","text":"<p>A powerful LLM (e.g., <code>llama3.1</code>) focused on global reasoning. It serves as \"The Big Brain\" which aggregates information from all zones and handles complex trade-offs or cascading failures that a single zone cannot resolve. It also serves as the user-facing natural language interface.</p>"},{"location":"core-concepts/#2-the-coordination-layer-zone-plcs","title":"2. The Coordination Layer (Zone PLCs)","text":"<p>Deterministic, rule-based coordinators (Programmable Logic Controllers) assigned to geographic subsets (zones) of the system. - They monitor local sensors continuously. - They use hard-coded safety logic (e.g., IEC 60255 protection rules) to handle fast localized violations. - They invoke local actuators (e.g., switching capacitors) to rectify issues deterministically without LLM latency. - If an issue is unresolvable locally using their protection thresholds, they escalate the issue to the Strategic Agent.</p>"},{"location":"core-concepts/#3-the-physical-layer-data-flow","title":"3. The Physical Layer &amp; Data Flow","text":"<ul> <li>Sensors: Small MCP server endpoints that provide read-only data (e.g., reading a voltage from the <code>grid_state.json</code> store).</li> <li>Actuators: MCP server endpoints that take action, modifying either the <code>grid_state</code> or invoking the <code>PowerGridAdapter</code> to run a simulation step.</li> <li>MCP Registry: The communication spine. All sensors and actuators announce their presence (host, port, tool schemas) to the <code>mcp-registry</code>. Agents query the registry to discover what physical tools are available in their assigned zone.</li> </ul> <p>Data Flow Summary: <code>Simulation Step</code> -&gt; <code>Sensor Servers Update State</code> -&gt; <code>Monitoring Loop Detects Violation</code> -&gt; <code>Assigns to Zone PLC</code> -&gt; <code>PLC Evaluates Rules</code> -&gt; <code>PLC Calls Actuator Tool</code> -&gt; <code>Simulation Updates</code>.</p>"},{"location":"development/","title":"Developer Guide","text":"<p>This guide covers how to extend the MCP multi-agent framework by adding new domains, creating sensors/actuators, and testing the system.</p>"},{"location":"development/#extending-base_adapterpy","title":"Extending <code>base_adapter.py</code>","text":"<p>If you are adding a new domain (e.g., Robotics), you must implement the <code>BaseAdapter</code> interface.</p> <pre><code>from src.domains.base_adapter import BaseAdapter\n\nclass RoboticsAdapter(BaseAdapter):\n    def initialize_simulation(self):\n        # Setup kinematic chains, physics engine, etc.\n        pass\n\n    def step_simulation(self):\n        # Advance the simulation by one tick\n        pass\n\n    def get_sensors(self):\n        # Return a list of sensor tools\n        pass\n\n    def get_actuators(self):\n        # Return a list of actuator tools\n        pass\n</code></pre>"},{"location":"development/#creating-new-sensors-or-actuators","title":"Creating New Sensors or Actuators","text":"<p>All components that expose data or functionality must be wrapped as an MCP Server.</p> <p>1. Define the Server: Use the <code>mcp.server.Server</code> class.</p> <p>2. Expose the Data/Action: Use the <code>@server.mcp.list_tools()</code> and <code>@server.mcp.call_tool()</code> decorators.</p> <pre><code>import mcp.server.Server\n\n# Example Custom Sensor\nsensor = mcp.server.Server(\"CustomVoltageSensor\")\n\n@sensor.mcp.list_tools()\nasync def list_tools() -&gt; list[Tool]:\n    return [Tool(name=\"read_voltage\", description=\"Reads voltage at bus 5\")]\n\n@sensor.mcp.call_tool()\nasync def call_tool(name: str, arguments: dict) -&gt; list[TextContent]:\n    if name == \"read_voltage\":\n        # fetch from grid_state.json or memory\n        return [TextContent(type=\"text\", text=\"1.05 p.u.\")]\n</code></pre> <p>3. Registration: Ensure the new server registers itself with the <code>mcp-registry</code> on startup so the Strategic Agent or Zone Coordinators can find it.</p>"},{"location":"development/#running-the-test-suite","title":"Running the Test Suite","text":"<p>We use <code>pytest</code> for all unit and integration testing.</p> <pre><code>uv run pytest tests/\n</code></pre> <p>To run with coverage: <pre><code>uv run pytest --cov=src tests/\n</code></pre></p> <p>Continuous Integration (CI) will enforce that these tests pass on every pull request to <code>main</code>.</p>"}]}