{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MCP Multi-Agent System","text":"<p>Elevator Pitch: A hierarchical, multi-agent simulation where specialized Large Language Models (LLMs) collaborate via the Model Context Protocol (MCP) to monitor, optimize, and safely control critical physical infrastructure (like power grids, robotics, or satellite networks) autonomously.</p> <p>This documentation serves all users of the system: 1. Core Concepts: Understand how the layers (Strategic, Coordination, Physical) interact. 2. Configuration: Environment variables and state storage details. 3. Developer Guide: How to create new MCP sensor servers or physical domain adapters. 4. API Reference: Autogenerated Python API documentation.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section contains automatically generated API documentation from the Python source code, utilizing <code>mkdocstrings</code>.</p>"},{"location":"api/#coordination-layer","title":"Coordination Layer","text":""},{"location":"api/#zone-coordinator","title":"Zone Coordinator","text":""},{"location":"api/#src.coordination.zone_coordinator","title":"<code>src.coordination.zone_coordinator</code>","text":"<p>Zone/Substation Coordinator MCP Server.</p> <p>Each zone coordinator manages a subset of buses/lines and provides: - Local optimization with its own LLM brain - Autonomous violation handling - Inter-zone coordination</p>"},{"location":"api/#src.coordination.zone_coordinator.ZoneCoordinator","title":"<code>ZoneCoordinator</code>","text":"<p>MCP server for a geographic zone of the power grid.</p> <p>Aggregates sensor data, runs local optimization, handles violations, and coordinates with peer zones.</p> Source code in <code>src/coordination/zone_coordinator.py</code> <pre><code>class ZoneCoordinator:\n    \"\"\"MCP server for a geographic zone of the power grid.\n\n    Aggregates sensor data, runs local optimization, handles violations,\n    and coordinates with peer zones.\n    \"\"\"\n\n    def __init__(\n        self,\n        zone_id: str,\n        grid: PowerGridSimulation,\n        buses: list[int],\n        lines: list[int]\n    ):\n        self.zone_id = zone_id\n        self.grid = grid\n        self.buses = buses\n        self.lines = lines\n        self.server_id = f\"coordinator_{zone_id}_{uuid.uuid4().hex[:8]}\"\n        self.name = f\"Zone Coordinator PLC ({zone_id})\"\n        self.optimizer = ZoneOptimizer(grid, zone_id, buses, lines)\n        self.audit_log = ZoneAuditLogger()\n        self.mqtt: MQTTClient | None = None\n\n        # Deterministic Protection Thresholds (adjustable via MCP)\n        self.protection_settings = {\n            \"under_voltage_pu\": 0.95,\n            \"over_voltage_pu\": 1.05,\n            \"max_line_loading_pct\": 100.0,\n        }\n\n        # State tracking for deadband/escalation\n        self._consecutive_violations = 0\n\n        self.mcp = Server(self.name)\n        self._register_tools()\n\n    def _register_tools(self) -&gt; None:\n        @self.mcp.list_tools()\n        async def list_tools() -&gt; list[Tool]:\n            return [\n                Tool(\n                    name=\"get_zone_status\",\n                    description=f\"Get comprehensive status of {self.zone_id}\",\n                    inputSchema={\"type\": \"object\", \"properties\": {}},\n                ),\n                Tool(\n                    name=\"optimize_zone_topology\",\n                    description=f\"Optimize {self.zone_id} for a given objective\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"objective\": {\n                                \"type\": \"string\",\n                                \"enum\": [\"min_losses\", \"min_voltage_deviation\", \"balance_loading\"],\n                                \"description\": \"Optimization objective\",\n                            }\n                        },\n                        \"required\": [\"objective\"],\n                    },\n                ),\n                Tool(\n                    name=\"handle_violation\",\n                    description=f\"Handle a constraint violation in {self.zone_id}\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"violation_type\": {\"type\": \"string\", \"enum\": [\"voltage\", \"thermal\", \"frequency\"]},\n                            \"affected_components\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n                        },\n                        \"required\": [\"violation_type\"],\n                    },\n                ),\n                Tool(\n                    name=\"load_balancing\",\n                    description=f\"Redistribute load within {self.zone_id}\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"target_balance\": {\"type\": \"number\", \"description\": \"Target loading % per line (0-100)\"}\n                        },\n                    },\n                ),\n                Tool(\n                    name=\"voltage_regulation\",\n                    description=f\"Adjust voltage profile in {self.zone_id}\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"target_pu\": {\"type\": \"number\", \"description\": \"Target voltage in p.u.\", \"default\": 1.0}\n                        },\n                    },\n                ),\n                Tool(\n                    name=\"emergency_islanding\",\n                    description=f\"Isolate {self.zone_id} from the rest of the grid\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"reason\": {\"type\": \"string\"}\n                        },\n                        \"required\": [\"reason\"],\n                    },\n                ),\n                Tool(\n                    name=\"detect_violations\",\n                    description=f\"Scan {self.zone_id} for constraint violations\",\n                    inputSchema={\"type\": \"object\", \"properties\": {}},\n                ),\n                Tool(\n                    name=\"execute_safety_rules\",\n                    description=f\"Evaluate deterministic IEC 60255 protection rules for {self.zone_id} and execute hardware actions\",\n                    inputSchema={\"type\": \"object\", \"properties\": {}},\n                ),\n                Tool(\n                    name=\"update_protection_settings\",\n                    description=f\"Update protection relay trip thresholds for {self.zone_id}\",\n                    inputSchema={\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"under_voltage_pu\": {\"type\": \"number\", \"description\": \"Trip threshold for under-voltage\"},\n                            \"over_voltage_pu\": {\"type\": \"number\", \"description\": \"Trip threshold for over-voltage\"},\n                            \"max_line_loading_pct\": {\"type\": \"number\", \"description\": \"Trip threshold for thermal overload\"},\n                        },\n                    },\n                ),\n            ]\n\n        @self.mcp.call_tool()\n        async def call_tool(name: str, arguments: dict) -&gt; list[TextContent]:\n            try:\n                if name == \"get_zone_status\":\n                    result = self._get_zone_status()\n                elif name == \"optimize_zone_topology\":\n                    result = self.optimizer.optimize(arguments[\"objective\"])\n                elif name == \"handle_violation\":\n                    result = self._handle_violation(arguments)\n                elif name == \"load_balancing\":\n                    result = self.optimizer.balance_loading(arguments.get(\"target_balance\", 80))\n                elif name == \"voltage_regulation\":\n                    result = self.optimizer.regulate_voltage(arguments.get(\"target_pu\", 1.0))\n                elif name == \"emergency_islanding\":\n                    result = self._emergency_island(arguments.get(\"reason\", \"\"))\n                elif name == \"detect_violations\":\n                    result = self._detect_violations()\n                elif name == \"execute_safety_rules\":\n                    result = self._evaluate_safety_rules()\n                elif name == \"update_protection_settings\":\n                    self.protection_settings.update({k: v for k, v in arguments.items() if v is not None})\n                    self.audit_log.log_event(self.zone_id, \"SETTINGS_UPDATED\", \"Protection thresholds revised\", details=self.protection_settings)\n                    self._broadcast_state(\"settings_updated\", self.protection_settings)\n                    result = {\"status\": \"success\", \"settings\": self.protection_settings}\n                else:\n                    result = {\"error\": f\"Unknown tool: {name}\"}\n                return [TextContent(type=\"text\", text=json.dumps(result, default=str))]\n            except Exception as e:\n                logger.error(\"Error in coordinator %s.%s: %s\", self.zone_id, name, e)\n                return [TextContent(type=\"text\", text=json.dumps({\"error\": str(e)}))]\n\n    # ------------------------------------------------------------------\n    # Status\n    # ------------------------------------------------------------------\n\n    def _get_zone_status(self) -&gt; dict:\n        voltages = {b: self.grid.get_bus_voltage(b) for b in self.buses}\n        loadings = {}\n        for lid in self.lines:\n            try:\n                loadings[lid] = float(self.grid.net.res_line.loading_percent.at[lid])\n            except (KeyError, IndexError):\n                pass\n\n        # Loads in zone\n        zone_loads = self.grid.net.load[self.grid.net.load.bus.isin(self.buses)]\n        total_load = float(zone_loads.p_mw.sum()) if len(zone_loads) &gt; 0 else 0\n\n        # Generators in zone\n        zone_gens = self.grid.net.gen[self.grid.net.gen.bus.isin(self.buses)]\n        total_gen = float(zone_gens.p_mw.sum()) if len(zone_gens) &gt; 0 else 0\n\n        violations = self._detect_violations()\n\n        return {\n            \"zone_id\": self.zone_id,\n            \"buses\": self.buses,\n            \"num_lines\": len(self.lines),\n            \"voltages\": {str(k): round(v, 4) for k, v in voltages.items()},\n            \"min_voltage\": round(min(voltages.values()), 4) if voltages else None,\n            \"max_voltage\": round(max(voltages.values()), 4) if voltages else None,\n            \"avg_line_loading\": round(sum(loadings.values()) / max(len(loadings), 1), 2),\n            \"max_line_loading\": round(max(loadings.values()), 2) if loadings else 0,\n            \"total_load_mw\": round(total_load, 2),\n            \"total_gen_mw\": round(total_gen, 2),\n            \"violations\": violations,\n            \"health\": \"critical\" if violations.get(\"count\", 0) &gt; 2 else \"warning\" if violations.get(\"count\", 0) &gt; 0 else \"normal\",\n        }\n\n    # ------------------------------------------------------------------\n    # Violation handling\n    # ------------------------------------------------------------------\n\n    def _detect_violations(self) -&gt; dict:\n        violations = []\n        for b in self.buses:\n            try:\n                vm = self.grid.get_bus_voltage(b)\n                if vm &lt; self.protection_settings[\"under_voltage_pu\"]:\n                    violations.append({\"type\": \"voltage_low\", \"bus\": b, \"value\": round(vm, 4), \"limit\": self.protection_settings[\"under_voltage_pu\"]})\n                elif vm &gt; self.protection_settings[\"over_voltage_pu\"]:\n                    violations.append({\"type\": \"voltage_high\", \"bus\": b, \"value\": round(vm, 4), \"limit\": self.protection_settings[\"over_voltage_pu\"]})\n            except (KeyError, IndexError):\n                pass\n\n        for lid in self.lines:\n            try:\n                loading = float(self.grid.net.res_line.loading_percent.at[lid])\n                if loading &gt; self.protection_settings[\"max_line_loading_pct\"]:\n                    violations.append({\"type\": \"thermal\", \"line\": lid, \"value\": round(loading, 2), \"limit\": self.protection_settings[\"max_line_loading_pct\"]})\n            except (KeyError, IndexError):\n                pass\n\n        return {\"violations\": violations, \"count\": len(violations), \"zone\": self.zone_id}\n\n    def _handle_violation(self, args: dict) -&gt; dict:\n        vtype = args[\"violation_type\"]\n        affected = args.get(\"affected_components\", [])\n\n        if vtype == \"voltage\":\n            return self.optimizer.regulate_voltage(1.0)\n        elif vtype == \"thermal\":\n            return self.optimizer.balance_loading(80)\n        elif vtype == \"frequency\":\n            return {\"action\": \"frequency_response\", \"message\": \"Frequency handled at system level\"}\n        else:\n            return {\"error\": f\"Unknown violation type: {vtype}\"}\n\n    def _emergency_island(self, reason: str) -&gt; dict:\n        \"\"\"Isolate the zone by opening all tie lines.\"\"\"\n        all_lines = list(self.grid.net.line.index)\n        tie_lines = []\n        for lid in all_lines:\n            fb = int(self.grid.net.line.from_bus.at[lid])\n            tb = int(self.grid.net.line.to_bus.at[lid])\n            in_zone = fb in self.buses or tb in self.buses\n            both_in = fb in self.buses and tb in self.buses\n            if in_zone and not both_in:\n                tie_lines.append(lid)\n\n        # Validate first\n        snapshot = self.grid.save_snapshot()\n        for lid in tie_lines:\n            self.grid.net.line.in_service.at[lid] = False\n\n        converged = self.grid.run_power_flow()\n        if not converged:\n            self.grid.restore_snapshot(snapshot)\n            return {\"islanded\": False, \"reason\": \"Power flow does not converge after islanding\", \"tie_lines\": tie_lines}\n\n        return {\n            \"islanded\": True,\n            \"reason\": reason,\n            \"tie_lines_opened\": tie_lines,\n            \"converged\": converged,\n        }\n\n    # ------------------------------------------------------------------\n    # Deterministic PLC Logic (IEC 60255 Emulation)\n    # ------------------------------------------------------------------\n\n    def _evaluate_safety_rules(self) -&gt; dict:\n        \"\"\"Deterministic rule engine executing hard-coded safety logic.\"\"\"\n        status = self._get_zone_status()\n        violations = self._detect_violations()\n        v_list = violations.get(\"violations\", [])\n\n        actions_taken = []\n        events_logged = []\n        escalate = False\n\n        if violations[\"count\"] &gt; 0:\n            self._consecutive_violations += 1\n        else:\n            self._consecutive_violations = 0\n\n        topics = []\n\n        # Rule 4: Strategic Escalation Deadband\n        if self._consecutive_violations &gt;= 3:\n            msg = f\"Escalating: Unable to resolve {violations['count']} violations after 3 cycles.\"\n            self.audit_log.log_event(self.zone_id, \"ESCALATION\", msg, details=violations)\n            self._broadcast_state(\"escalation\", {\"violations\": violations})\n            return {\n                \"zone\": self.zone_id,\n                \"status\": \"escalation_required\",\n                \"violations\": violations,\n                \"message\": msg\n            }\n\n        # Rule 1 &amp; Rule 2: Voltage Protection (ANSI 27 &amp; 59 / IEC 60255-127)\n        if any(v[\"type\"] in (\"voltage_low\", \"voltage_high\") for v in v_list):\n            msg = \"IEC 60255-127 Voltage Relay Triggered.\"\n            result = self.optimizer.regulate_voltage(1.0)\n            act = \"Capacitor banks switched to regulate voltage.\"\n            actions_taken.append({\"action\": \"voltage_regulation\", \"result\": result})\n            self.audit_log.log_event(self.zone_id, \"RELAY_TRIP\", msg, action_taken=act, details=result)\n            topics.append(\"relay_trip\")\n            events_logged.append(msg)\n\n        # Rule 3: Thermal Overload (ANSI 50/51 / IEC 60255-151)\n        if any(v[\"type\"] == \"thermal\" for v in v_list):\n            msg = \"IEC 60255-151 Overcurrent Relay Triggered.\"\n            # Shed load dynamically, aiming for 95% of limit to create buffer\n            target = self.protection_settings[\"max_line_loading_pct\"] * 0.95\n            result = self.optimizer.balance_loading(target)\n            act = f\"Local demand response triggered (Target: {target}%).\"\n            actions_taken.append({\"action\": \"thermal_protection\", \"result\": result})\n            self.audit_log.log_event(self.zone_id, \"RELAY_TRIP\", msg, action_taken=act, details=result)\n            topics.append(\"relay_trip\")\n            events_logged.append(msg)\n\n        post_violations = self._detect_violations()\n\n        result_payload = {\n            \"zone\": self.zone_id,\n            \"violations_before\": violations.get(\"count\", 0),\n            \"violations_after\": post_violations.get(\"count\", 0),\n            \"actions_taken\": actions_taken,\n            \"events\": events_logged,\n            \"mode\": \"deterministic_plc\",\n        }\n\n        # Broadcast status updates\n        self._broadcast_state(\"status\", self._get_zone_status())\n        for topic in topics:\n            self._broadcast_state(topic, result_payload)\n\n        return result_payload\n\n    # ------------------------------------------------------------------\n    # MQTT Communication\n    # ------------------------------------------------------------------\n\n    def _broadcast_state(self, topic_suffix: str, payload: dict) -&gt; None:\n        \"\"\"Broadcast an event or state over MQTT to all subscribers.\"\"\"\n        if not self.mqtt:\n            return\n\n        topic = f\"grid/{self.zone_id}/{topic_suffix}\"\n\n        # We fire and forget asynchronously in the background\n        import asyncio\n        asyncio.create_task(self._publish_async(topic, payload))\n\n    async def _publish_async(self, topic: str, payload: dict) -&gt; None:\n        try:\n            msg = json.dumps(payload, default=str)\n            await self.mqtt.publish(topic, msg)\n        except Exception as e:\n            logger.error(\"Failed to broadcast on %s: %s\", topic, e)\n\n    # ------------------------------------------------------------------\n    # Registry\n    # ------------------------------------------------------------------\n\n    def get_registration(self) -&gt; MCPServerRegistration:\n        tools = [\n            ToolDescriptor(name=\"get_zone_status\", description=\"Zone status overview\", safety_level=SafetyLevel.READ_ONLY),\n            ToolDescriptor(name=\"optimize_zone_topology\", description=\"Local optimization\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"handle_violation\", description=\"Violation response\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"load_balancing\", description=\"Load redistribution\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"voltage_regulation\", description=\"Voltage control\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"emergency_islanding\", description=\"Zone isolation\", safety_level=SafetyLevel.HIGH_RISK),\n            ToolDescriptor(name=\"detect_violations\", description=\"Violation scan\", safety_level=SafetyLevel.READ_ONLY),\n            ToolDescriptor(name=\"execute_safety_rules\", description=\"PLC Deterministic Rules Evaluation\", safety_level=SafetyLevel.MEDIUM_RISK),\n            ToolDescriptor(name=\"update_protection_settings\", description=\"Revise safety thresholds\", safety_level=SafetyLevel.HIGH_RISK),\n        ]\n        return MCPServerRegistration(\n            server_id=self.server_id,\n            name=self.name,\n            layer=\"coordination\",\n            domain=\"power_grid\",\n            zone=self.zone_id,\n            transport=\"stdio\",\n            tools=tools,\n        )\n\n    async def register_with_registry(self) -&gt; None:\n        settings = get_settings()\n        reg = self.get_registration()\n        try:\n            async with httpx.AsyncClient() as client:\n                resp = await client.post(\n                    f\"{settings.registry_url}/register\",\n                    json=reg.model_dump(mode=\"json\"),\n                )\n                resp.raise_for_status()\n                logger.info(\"Registered %s with registry\", self.name)\n        except Exception as e:\n            logger.warning(\"Failed to register with registry: %s\", e)\n\n    async def run(self) -&gt; None:\n        settings = get_settings()\n        self.mqtt = MQTTClient(\n            settings.mqtt_broker,\n            settings.mqtt_port,\n            client_id=f\"zone_{self.zone_id}_{uuid.uuid4().hex[:4]}\"\n        )\n        await self.mqtt.connect()\n        self.audit_log.log_event(self.zone_id, \"SYSTEM_START\", \"Zone PLC Relay Initialized Offline\", details={\"buses\": self.buses})\n\n        await self.register_with_registry()\n\n        async with stdio_server() as (read, write):\n            await self.mcp.run(read, write, self.mcp.create_initialization_options())\n</code></pre>"},{"location":"api/#domain-adapters","title":"Domain Adapters","text":""},{"location":"api/#base-adapter","title":"Base Adapter","text":""},{"location":"api/#src.domains.base_adapter","title":"<code>src.domains.base_adapter</code>","text":"<p>Abstract base class for domain adapters.</p> <p>Each domain (power grid, robotics, satellite) extends this to provide domain-specific sensors, actuators, and coordinators.</p>"},{"location":"api/#src.domains.base_adapter.DomainAdapter","title":"<code>DomainAdapter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract domain adapter providing a uniform interface for multi-domain support.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>class DomainAdapter(ABC):\n    \"\"\"Abstract domain adapter providing a uniform interface for multi-domain support.\"\"\"\n\n    @property\n    @abstractmethod\n    def domain_name(self) -&gt; str:\n        \"\"\"Return the domain identifier (e.g., 'power_grid', 'robotics').\"\"\"\n        ...\n\n    @abstractmethod\n    def get_sensor_types(self) -&gt; list[dict]:\n        \"\"\"Return list of sensor type definitions for this domain.\"\"\"\n        ...\n\n    @abstractmethod\n    def get_actuator_types(self) -&gt; list[dict]:\n        \"\"\"Return list of actuator type definitions for this domain.\"\"\"\n        ...\n\n    @abstractmethod\n    def create_sensors(self, simulation: Any) -&gt; list[Any]:\n        \"\"\"Instantiate all sensor MCP servers for this domain.\"\"\"\n        ...\n\n    @abstractmethod\n    def create_actuators(self, simulation: Any) -&gt; list[Any]:\n        \"\"\"Instantiate all actuator MCP servers for this domain.\"\"\"\n        ...\n\n    @abstractmethod\n    def create_coordinators(self, simulation: Any) -&gt; list[Any]:\n        \"\"\"Instantiate zone/area coordinator MCP servers.\"\"\"\n        ...\n\n    def get_constraints(self) -&gt; dict:\n        \"\"\"Return domain-specific constraints and limits.\"\"\"\n        return {}\n\n    def get_safety_rules(self) -&gt; list[str]:\n        \"\"\"Return domain-specific safety rules.\"\"\"\n        return []\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.domain_name","title":"<code>domain_name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the domain identifier (e.g., 'power_grid', 'robotics').</p>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.create_actuators","title":"<code>create_actuators(simulation)</code>  <code>abstractmethod</code>","text":"<p>Instantiate all actuator MCP servers for this domain.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef create_actuators(self, simulation: Any) -&gt; list[Any]:\n    \"\"\"Instantiate all actuator MCP servers for this domain.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.create_coordinators","title":"<code>create_coordinators(simulation)</code>  <code>abstractmethod</code>","text":"<p>Instantiate zone/area coordinator MCP servers.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef create_coordinators(self, simulation: Any) -&gt; list[Any]:\n    \"\"\"Instantiate zone/area coordinator MCP servers.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.create_sensors","title":"<code>create_sensors(simulation)</code>  <code>abstractmethod</code>","text":"<p>Instantiate all sensor MCP servers for this domain.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef create_sensors(self, simulation: Any) -&gt; list[Any]:\n    \"\"\"Instantiate all sensor MCP servers for this domain.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.get_actuator_types","title":"<code>get_actuator_types()</code>  <code>abstractmethod</code>","text":"<p>Return list of actuator type definitions for this domain.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef get_actuator_types(self) -&gt; list[dict]:\n    \"\"\"Return list of actuator type definitions for this domain.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.get_constraints","title":"<code>get_constraints()</code>","text":"<p>Return domain-specific constraints and limits.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>def get_constraints(self) -&gt; dict:\n    \"\"\"Return domain-specific constraints and limits.\"\"\"\n    return {}\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.get_safety_rules","title":"<code>get_safety_rules()</code>","text":"<p>Return domain-specific safety rules.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>def get_safety_rules(self) -&gt; list[str]:\n    \"\"\"Return domain-specific safety rules.\"\"\"\n    return []\n</code></pre>"},{"location":"api/#src.domains.base_adapter.DomainAdapter.get_sensor_types","title":"<code>get_sensor_types()</code>  <code>abstractmethod</code>","text":"<p>Return list of sensor type definitions for this domain.</p> Source code in <code>src/domains/base_adapter.py</code> <pre><code>@abstractmethod\ndef get_sensor_types(self) -&gt; list[dict]:\n    \"\"\"Return list of sensor type definitions for this domain.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#power-grid-adapter","title":"Power Grid Adapter","text":""},{"location":"api/#src.domains.power_grid","title":"<code>src.domains.power_grid</code>","text":""},{"location":"configuration/","title":"Configuration Guide","text":"<p>The project leverages both environment variables and on-disk JSON data stores to share state seamlessly between the simulation, the MCP registry, and the various operational agents.</p>"},{"location":"configuration/#environment-variables-env","title":"Environment Variables (<code>.env</code>)","text":"<p>The system requires an environment file (<code>.env</code>) placed in the root directory. Copy the <code>.env.example</code> file to start.</p> Variable Description Default <code>STRATEGIC_MODEL</code> The LLM model name used for the top-level Strategic Agent. <code>llama3.1:latest</code> <p>| <code>LLM_API_KEY</code> | Key for authentication (can be anything if local). | <code>ollama</code> | | <code>LLM_BASE_URL</code> | Endpoint for the OpenAI-compatible completion API. | <code>http://localhost:11434</code> | | <code>LLM_CONTEXT_WINDOW</code> | Maximum tokens allowed for the context window. | <code>8192</code> |</p>"},{"location":"configuration/#state-management-files","title":"State Management Files","text":""},{"location":"configuration/#grid_statejson","title":"<code>grid_state.json</code>","text":"<p>This is the central \"digital twin\" storage file updated continuously by the <code>PowerGridAdapter</code>.  It holds the latest snapshot of the physical simulation.</p> <p>Structure:</p> <pre><code>{\n  \"timestamp\": \"2023-10-24T12:00:00Z\",\n  \"buses\": [\n    {\n      \"id\": 0,\n      \"zone\": \"Zone 1\",\n      \"voltage_pu\": 1.02,\n      \"type\": \"slack\"\n    }\n  ],\n  \"lines\": [\n    {\n      \"id\": 0,\n      \"from_bus\": 0,\n      \"to_bus\": 1,\n      \"loading_percent\": 45.3,\n      \"status\": \"closed\"\n    }\n  ],\n  \"generators\": [...],\n  \"loads\": [...]\n}\n</code></pre>"},{"location":"configuration/#registry_storejson","title":"<code>registry_store.json</code>","text":"<p>This file is managed exclusively by the <code>mcp-registry</code> (FastAPI). It holds a list of all currently active MCP servers (sensors, actuators, coordinators).</p> <p>Structure:</p> <pre><code>{\n  \"servers\": {\n    \"voltage_sensor_zone1\": {\n      \"type\": \"sensor\",\n      \"url\": \"http://localhost:8001/mcp\",\n      \"status\": \"online\",\n      \"last_heartbeat\": \"2023-10-24T12:00:05Z\"\n    },\n    ...\n  }\n}\n</code></pre> <p>Agents query this file (via the registry API) to perform dynamic tool discovery.</p>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>The MCP Multi-Agent System is designed to seamlessly integrate Large Language Models (LLMs) with simulated physical systems. </p>"},{"location":"core-concepts/#the-domains","title":"The Domains","text":"<p>The architecture supports various physical domains by wrapping their simulation data into standard Model Context Protocol (MCP) servers.</p> <ul> <li>Power Grid (IEEE 30-bus): The primary simulation provided. It models the generation, transmission, and load aspects of an electrical grid using <code>pandapower</code>. It provides sensor data (voltage, current, frequency) and actuator controls (breakers, generators).</li> <li>Robotics (Future Extension): Control endpoints for individual servos, kinematics calculations, and LiDAR sensor simulation.</li> <li>Satellite (Future Extension): Orbital parameters, communication bandwidth, and power management simulations.</li> </ul>"},{"location":"core-concepts/#the-multi-agent-system","title":"The Multi-Agent System","text":"<p>The system operates across three tiers:</p>"},{"location":"core-concepts/#1-the-strategic-agent-system-wide","title":"1. The Strategic Agent (System-wide)","text":"<p>A powerful LLM (e.g., <code>llama3.1</code>) focused on global reasoning. It serves as \"The Big Brain\" which aggregates information from all zones and handles complex trade-offs or cascading failures that a single zone cannot resolve. It also serves as the user-facing natural language interface.</p>"},{"location":"core-concepts/#2-the-coordination-layer-zone-plcs","title":"2. The Coordination Layer (Zone PLCs)","text":"<p>Deterministic, rule-based coordinators (Programmable Logic Controllers) assigned to geographic subsets (zones) of the system. - They monitor local sensors continuously. - They use hard-coded safety logic (e.g., IEC 60255 protection rules) to handle fast localized violations. - They invoke local actuators (e.g., switching capacitors) to rectify issues deterministically without LLM latency. - If an issue is unresolvable locally using their protection thresholds, they escalate the issue to the Strategic Agent.</p>"},{"location":"core-concepts/#3-the-physical-layer-data-flow","title":"3. The Physical Layer &amp; Data Flow","text":"<ul> <li>Sensors: Small MCP server endpoints that provide read-only data (e.g., reading a voltage from the <code>grid_state.json</code> store).</li> <li>Actuators: MCP server endpoints that take action, modifying either the <code>grid_state</code> or invoking the <code>PowerGridAdapter</code> to run a simulation step.</li> <li>MCP Registry: The communication spine. All sensors and actuators announce their presence (host, port, tool schemas) to the <code>mcp-registry</code>. Agents query the registry to discover what physical tools are available in their assigned zone.</li> </ul> <p>Data Flow Summary: <code>Simulation Step</code> -&gt; <code>Sensor Servers Update State</code> -&gt; <code>Monitoring Loop Detects Violation</code> -&gt; <code>Assigns to Zone PLC</code> -&gt; <code>PLC Evaluates Rules</code> -&gt; <code>PLC Calls Actuator Tool</code> -&gt; <code>Simulation Updates</code>.</p>"},{"location":"development/","title":"Developer Guide","text":"<p>This guide covers how to extend the MCP multi-agent framework by adding new domains, creating sensors/actuators, and testing the system.</p>"},{"location":"development/#extending-base_adapterpy","title":"Extending <code>base_adapter.py</code>","text":"<p>If you are adding a new domain (e.g., Robotics), you must implement the <code>BaseAdapter</code> interface.</p> <pre><code>from src.domains.base_adapter import BaseAdapter\n\nclass RoboticsAdapter(BaseAdapter):\n    def initialize_simulation(self):\n        # Setup kinematic chains, physics engine, etc.\n        pass\n\n    def step_simulation(self):\n        # Advance the simulation by one tick\n        pass\n\n    def get_sensors(self):\n        # Return a list of sensor tools\n        pass\n\n    def get_actuators(self):\n        # Return a list of actuator tools\n        pass\n</code></pre>"},{"location":"development/#creating-new-sensors-or-actuators","title":"Creating New Sensors or Actuators","text":"<p>All components that expose data or functionality must be wrapped as an MCP Server.</p> <p>1. Define the Server: Use the <code>mcp.server.Server</code> class.</p> <p>2. Expose the Data/Action: Use the <code>@server.mcp.list_tools()</code> and <code>@server.mcp.call_tool()</code> decorators.</p> <pre><code>import mcp.server.Server\n\n# Example Custom Sensor\nsensor = mcp.server.Server(\"CustomVoltageSensor\")\n\n@sensor.mcp.list_tools()\nasync def list_tools() -&gt; list[Tool]:\n    return [Tool(name=\"read_voltage\", description=\"Reads voltage at bus 5\")]\n\n@sensor.mcp.call_tool()\nasync def call_tool(name: str, arguments: dict) -&gt; list[TextContent]:\n    if name == \"read_voltage\":\n        # fetch from grid_state.json or memory\n        return [TextContent(type=\"text\", text=\"1.05 p.u.\")]\n</code></pre> <p>3. Registration: Ensure the new server registers itself with the <code>mcp-registry</code> on startup so the Strategic Agent or Zone Coordinators can find it.</p>"},{"location":"development/#running-the-test-suite","title":"Running the Test Suite","text":"<p>We use <code>pytest</code> for all unit and integration testing.</p> <pre><code>uv run pytest tests/\n</code></pre> <p>To run with coverage:</p> <pre><code>uv run pytest --cov=src tests/\n</code></pre> <p>Continuous Integration (CI) will enforce that these tests pass on every pull request to <code>main</code>.</p>"}]}